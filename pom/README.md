# springDeepMind 
深入spring源码解析和学习


## aop

### aop 术语

#### advice 通知
advice 定义了切面是什么以及何时使用，when+what效果

例如：spring 切面对应5种类型通知：
1. Before
2. After
3. After-returning 在方法成功执行之后调用
4. After-throwing 在方法抛出异常后调用
5. Around

#### join point 连接点
在应用执行过程中，能够插入切面的一个点，可以理解为**where**.目前spring aop 只支持 到方法级别，
可以理解为join point 就是方法执行时候

#### pointcut 切点
切点是对连接点的一个表达式，通过匹配表达式实现区域性的面，可以理解为切点就是将符合表达式（express）的连接点连接起来

#### aspect 切面
切面是通知（advice）和切点（pointcut）的结合，即是他们结合的统称，可以理解为when,where,how串联效果

#### 目标对象 target
即aop 的切入目标类

#### 高级术语
*. 引入(introduction):特殊增强，为目标类**动态添加属性或者方法**.

*. 织入(Weaving): 是将advice添加到目标类具体连接点上的**过程**。目前aop有三种织入过程：
1. 编译器织入，需要特殊的 java编译器
2. 类装载期织入，需要特殊的类装载器
3. 动态代理织入，在运行期为目标添加增强生成子类的方式

>Spring 采用动态代理织入, AspectJ采用编译器织入和类装载器织入

### AOP实现者
1. AspectJ (2005年 AspectJ和AspectWerkz 合并)
2. JBoss AOP
3. Spring AOP

### aop 实现

#### 接口实现

#### xml实现

#### AspectJ实现
在spring中使用AspectJ必须满足以下前提：
1. jdk 5.0+ 必须实现注解
2. aspectJ.waever 和aspectj.tools jar包
3. 添加spring的asm 轻量级字节码框架，因为解析aspectJ 表达式不能通过jdk反射获取入参名

使用步骤：
1. 启动 aspectJ 自动注入驱动：
1.1 注解方式@AspectJ
1.2 Xml 方式：`<aop:annotation-driven/>`  这里前提需要引入aop前缀 schema

2. 使用 Aspectj 注解
在注解配置文件上添加`@EnableAspectJAutoProxy`，即可实现aspectJ自动注入驱动


#### AspectJ 切点
由于spring只支持方法连接点，所以注解只支持部分aspectj的注解

Spring 支持9个AspectJ的切点表达式函数，大致分为四类
1. 方法切点函数：通过描述目标类方法信息定义连接点
2. 方法入参切点，通过描绘目标类方法入参的信息定义连接点
3. 目标类切点函数：通过目标类类型信息定义连接点
4. 代理类切点函数： 通过描述目标类的代理类信息定义连接点

切点表达式列表：
|类别|函数|入参|说明|
|---|---|----|---|
|方法切点|execution()|方法匹配模式表达式|表示满足某一个匹配模式的多有目标类方法的连接点|
|方法切点|@annotation()|方法注解类名|表示标注了特定注解的目标方|
|方法入参切点函数|args()|类名|通过判断目标类方法运行时入参对象的类型定义指定连接点|
|方法入参切点函数|@args()|类型注解类名|通过判断目标类方法运行时入参的类型是否标注特定注解来定义连接点|
|目标类切点函数|within()|类名匹配串|表示特定域下的所有连接点(所有方法)|
|目标类切点函数|target()|类名？(不能表达式？)|表示目标类按照特定类型匹配指定类,**被匹配的子类也会被包含**|
|目标类切点函数|@target()|注解类名|表示目标满足指定注解,**被匹配的子类也会被包含**|
|目标类切点函数|@within()|类名匹配串|表示特定域下满足指定注解的目标类下所有方法，**被匹配的子类也会被包含**|
|代理类切点|this()|类名|代理类按照类型匹配于指定类，命中的代理类的目标类所有的连接点匹配切点|

##### execution
>execution(<修饰符模式>? <返回类型> <方法名>(<参数>) <异常声明>?)

注意使用(通配符)[# 函数入参通配符]

##### args,@args
两者区别较大，args匹配入参类型，且包括子类（这里使用+通配符无意义）。但是，@args匹配包含入参类型标有指定注解的类型，这里匹配规则与args不相同
在spring 3.x之前@args匹配规则复杂，在此之后，直接匹配运行时入参参数是否标有该注解，有则匹配 * （4.x版本基础上测试是这样情况）


##### 函数入参通配符
* *匹配任意字符串，但是**只能匹配上下文的一个元素**
* .. 匹配任意字符串，可以匹配多个元素，**必须和*联合使用**，除了入参表达式
* +表示按照匹配指定类型所有扩展或者继承的类（包括自身）

> 函数支持通配符情况
1. 支持所有通配符：execution(),within()
2. 仅支持+ args(),this(),target()
3. 不支持同通配符:@args,@within,@target,@annotation

##### 逻辑运算符
1. &&(and)
2. ||(or)
3. ！(not)
> 如果not位于切点表达式开头，必须空格开头，否则出现解析异常

#### AspectJ advice

共有属性：
* value:定义切点
* argNames:由于java无法通过反射获取入参名，只能通过该属性获取，多个用逗号隔开

##### @Before
前置增强

##### @After
final后置增强,无论方法正常返回，无返回还是跑送异常，都将执行该增强


##### @AfterReturing
后置增强
* pointcut:指定切点信息，如果指定则覆盖 默认value属性
* returning:将目标返回对象方法返回值绑定给增强方法

##### @Around
环绕增强

##### @AfterThrowing
异常增强
* throwing：将抛出异常绑定到增强方法中

##### @DeclareParents
引介增强
* defaultImpl:默认的接口实现类







